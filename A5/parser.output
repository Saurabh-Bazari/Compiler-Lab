
Grammar
rule 1    grammar_start -> libraries decls INT MAIN LB RB lcf stmts rcf
rule 2    grammar_start -> error
rule 3    libraries -> LIBRARY libraries
rule 4    libraries -> LIBRARY
rule 5    decls -> decls decl
rule 6    decls ->		/* empty */
rule 7    decl -> func_decl
rule 8    decl -> var_decl
rule 9    decl -> exp SEMI
rule 10   var_decl -> type var_list SEMI
rule 11   var_decl -> type var EQUAL exp_type_1 SEMI
rule 12   type -> INT
rule 13   type -> FLOAT
rule 14   void -> VOID
rule 15   var_list -> var_list COMMA var
rule 16   var_list -> var
rule 17   var -> id
rule 18   var -> id br_list
rule 19   id -> ID
rule 20   br_list -> LBP intg RBP
rule 21   br_list -> br_list LBP intg RBP
rule 22   br_list1 -> LBP exp_type_1 RBP
rule 23   br_list1 -> br_list1 LBP exp_type_1 RBP
rule 24   func_decl -> type id lbf decl_plist RB lcf body rcf func_end
rule 25   func_decl -> void id lbf decl_plist RB lcf body rcf func_end
rule 26   lbf -> LB
rule 27   lcf -> LC
rule 28   rcf -> RC
rule 29   func_end ->		/* empty */
rule 30   @1 ->		/* empty */
rule 31   decl_plist -> @1 decl_pl
rule 32   decl_plist ->		/* empty */
rule 33   decl_pl -> decl_param COMMA decl_pl
rule 34   decl_pl -> decl_param
rule 35   decl_param -> type var
rule 36   body -> stmts
rule 37   body ->		/* empty */
rule 38   stmts -> stmt stmts
rule 39   stmts -> stmt
rule 40   stmt -> var_decl
rule 41   stmt -> exp SEMI
rule 42   stmt -> exp_type_1 SEMI
rule 43   stmt -> FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf
rule 44   stmt -> WHILE LB exp_type_1 RB lcf stmts rcf
rule 45   stmt -> IF LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf
rule 46   stmt -> IF LB exp_type_1 RB lcf stmts rcf
rule 47   stmt -> SWITCH LB exp_type_1 RB LC case_exp default_exp RC
rule 48   stmt -> continue SEMI
rule 49   stmt -> break SEMI
rule 50   stmt -> return_exp SEMI
rule 51   stmt -> lcf body rcf
rule 52   stmt -> error SEMI
rule 53   break -> BREAK
rule 54   continue -> CONTINUE
rule 55   case_exp -> CASE LB arith_exp_type_1 RB COLON lcf stmts rcf case_exp
rule 56   case_exp ->		/* empty */
rule 57   default_exp -> DEFAULT COLON lcf stmts rcf
rule 58   default_exp ->		/* empty */
rule 59   return_exp -> RETURN
rule 60   return_exp -> RETURN exp_type_1
rule 61   exp -> id EQUAL exp_type_1
rule 62   exp -> id br_list1 EQUAL exp_type_1
rule 63   exp_type_1 -> exp_type_1 OR exp_type_2
rule 64   exp_type_1 -> exp_type_2
rule 65   exp_type_2 -> exp_type_2 AND exp_type_3
rule 66   exp_type_2 -> exp_type_3
rule 67   exp_type_3 -> exp_type_3 relation_op arith_exp_type_1
rule 68   exp_type_3 -> arith_exp_type_1
rule 69   arith_exp_type_1 -> arith_exp_type_1 plus_minus_op arith_exp_type_2
rule 70   arith_exp_type_1 -> arith_exp_type_2
rule 71   arith_exp_type_2 -> arith_exp_type_2 mul_div_op unary_exp
rule 72   arith_exp_type_2 -> unary_exp
rule 73   unary_exp -> unary_operator term
rule 74   unary_exp -> term
rule 75   term -> LB exp_type_1 RB
rule 76   term -> func_call
rule 77   term -> consts
rule 78   term -> id
rule 79   term -> id br_list1
rule 80   func_call -> id LB args RB
rule 81   args -> args_list
rule 82   args ->		/* empty */
rule 83   args_list -> args_list COMMA arith_exp_type_1
rule 84   args_list -> arith_exp_type_1
rule 85   consts -> intg
rule 86   consts -> floats
rule 87   intg -> INTEGERS
rule 88   intg -> SUB INTEGERS
rule 89   floats -> FLOATING_POINTS
rule 90   floats -> SUB FLOATING_POINTS
rule 91   plus_minus_op -> ADD
rule 92   plus_minus_op -> SUB
rule 93   mul_div_op -> MUL
rule 94   mul_div_op -> DIV
rule 95   mul_div_op -> MOD
rule 96   relation_op -> GT
rule 97   relation_op -> LT
rule 98   relation_op -> GE
rule 99   relation_op -> LE
rule 100  relation_op -> EQ
rule 101  relation_op -> NE
rule 102  unary_operator -> SUB SUB
rule 103  unary_operator -> ADD ADD

Terminals, with rules where they appear

$ (-1)
error (256) 2 52
ADD (258) 91 103
SUB (259) 88 90 92 102
MUL (260) 93
DIV (261) 94
GT (262) 96
LT (263) 97
GE (264) 98
LBP (265) 20 21 22 23
RBP (266) 20 21 22 23
LE (267) 99
EQ (268) 100
NE (269) 101
MAIN (270) 1
INT (271) 1 12
FLOAT (272) 13
RETURN (273) 59 60
OR (274) 63
AND (275) 65
IF (276) 45 46
FOR (277) 43
WHILE (278) 44
ELSE (279) 45
BREAK (280) 53
CONTINUE (281) 54
INTEGERS (282) 87 88
FLOATING_POINTS (283) 89 90
ID (284) 19
SEMI (285) 9 10 11 41 42 43 48 49 50 52
LC (286) 27 47
RC (287) 28 47
LB (288) 1 26 43 44 45 46 47 55 75 80
RB (289) 1 24 25 43 44 45 46 47 55 75 80
COMMA (290) 15 33 83
EQUAL (291) 11 61 62
MOD (292) 95
LIBRARY (293) 3 4
VOID (294) 14
SWITCH (295) 47
CASE (296) 55
DEFAULT (297) 57
COLON (298) 55 57

Nonterminals, with rules where they appear

grammar_start (44)
    on left: 1 2
libraries (45)
    on left: 3 4, on right: 1 3
decls (46)
    on left: 5 6, on right: 1 5
decl (47)
    on left: 7 8 9, on right: 5
var_decl (48)
    on left: 10 11, on right: 8 40
type (49)
    on left: 12 13, on right: 10 11 24 35
void (50)
    on left: 14, on right: 25
var_list (51)
    on left: 15 16, on right: 10 15
var (52)
    on left: 17 18, on right: 11 15 16 35
id (53)
    on left: 19, on right: 17 18 24 25 61 62 78 79 80
br_list (54)
    on left: 20 21, on right: 18 21
br_list1 (55)
    on left: 22 23, on right: 23 62 79
func_decl (56)
    on left: 24 25, on right: 7
lbf (57)
    on left: 26, on right: 24 25
lcf (58)
    on left: 27, on right: 1 24 25 43 44 45 46 51 55 57
rcf (59)
    on left: 28, on right: 1 24 25 43 44 45 46 51 55 57
func_end (60)
    on left: 29, on right: 24 25
decl_plist (61)
    on left: 31 32, on right: 24 25
@1 (62)
    on left: 30, on right: 31
decl_pl (63)
    on left: 33 34, on right: 31 33
decl_param (64)
    on left: 35, on right: 33 34
body (65)
    on left: 36 37, on right: 24 25 51
stmts (66)
    on left: 38 39, on right: 1 36 38 43 44 45 46 55 57
stmt (67)
    on left: 40 41 42 43 44 45 46 47 48 49 50 51 52,
    on right: 38 39
break (68)
    on left: 53, on right: 49
continue (69)
    on left: 54, on right: 48
case_exp (70)
    on left: 55 56, on right: 47 55
default_exp (71)
    on left: 57 58, on right: 47
return_exp (72)
    on left: 59 60, on right: 50
exp (73)
    on left: 61 62, on right: 9 41 43
exp_type_1 (74)
    on left: 63 64, on right: 11 22 23 42 43 44 45 46 47 60 61 62 63
    75
exp_type_2 (75)
    on left: 65 66, on right: 63 64 65
exp_type_3 (76)
    on left: 67 68, on right: 65 66 67
arith_exp_type_1 (77)
    on left: 69 70, on right: 55 67 68 69 83 84
arith_exp_type_2 (78)
    on left: 71 72, on right: 69 70 71
unary_exp (79)
    on left: 73 74, on right: 71 72
term (80)
    on left: 75 76 77 78 79, on right: 73 74
func_call (81)
    on left: 80, on right: 76
args (82)
    on left: 81 82, on right: 80
args_list (83)
    on left: 83 84, on right: 81 83
consts (84)
    on left: 85 86, on right: 77
intg (85)
    on left: 87 88, on right: 20 21 85
floats (86)
    on left: 89 90, on right: 86
plus_minus_op (87)
    on left: 91 92, on right: 69
mul_div_op (88)
    on left: 93 94 95, on right: 71
relation_op (89)
    on left: 96 97 98 99 100 101, on right: 67
unary_operator (90)
    on left: 102 103, on right: 73


state 0

    error	shift, and go to state 1
    LIBRARY	shift, and go to state 2

    grammar_start	go to state 210
    libraries	go to state 3



state 1

    grammar_start  ->  error .   (rule 2)

    $default	reduce using rule 2 (grammar_start)



state 2

    libraries  ->  LIBRARY . libraries   (rule 3)
    libraries  ->  LIBRARY .   (rule 4)

    LIBRARY	shift, and go to state 2

    $default	reduce using rule 4 (libraries)

    libraries	go to state 4



state 3

    grammar_start  ->  libraries . decls INT MAIN LB RB lcf stmts rcf   (rule 1)

    $default	reduce using rule 6 (decls)

    decls	go to state 5



state 4

    libraries  ->  LIBRARY libraries .   (rule 3)

    $default	reduce using rule 3 (libraries)



state 5

    grammar_start  ->  libraries decls . INT MAIN LB RB lcf stmts rcf   (rule 1)
    decls  ->  decls . decl   (rule 5)

    INT 	shift, and go to state 6
    FLOAT	shift, and go to state 7
    ID  	shift, and go to state 8
    VOID	shift, and go to state 9

    decl	go to state 10
    var_decl	go to state 11
    type	go to state 12
    void	go to state 13
    id  	go to state 14
    func_decl	go to state 15
    exp 	go to state 16



state 6

    grammar_start  ->  libraries decls INT . MAIN LB RB lcf stmts rcf   (rule 1)
    type  ->  INT .   (rule 12)

    MAIN	shift, and go to state 17

    $default	reduce using rule 12 (type)



state 7

    type  ->  FLOAT .   (rule 13)

    $default	reduce using rule 13 (type)



state 8

    id  ->  ID .   (rule 19)

    $default	reduce using rule 19 (id)



state 9

    void  ->  VOID .   (rule 14)

    $default	reduce using rule 14 (void)



state 10

    decls  ->  decls decl .   (rule 5)

    $default	reduce using rule 5 (decls)



state 11

    decl  ->  var_decl .   (rule 8)

    $default	reduce using rule 8 (decl)



state 12

    var_decl  ->  type . var_list SEMI   (rule 10)
    var_decl  ->  type . var EQUAL exp_type_1 SEMI   (rule 11)
    func_decl  ->  type . id lbf decl_plist RB lcf body rcf func_end   (rule 24)

    ID  	shift, and go to state 8

    var_list	go to state 18
    var 	go to state 19
    id  	go to state 20



state 13

    func_decl  ->  void . id lbf decl_plist RB lcf body rcf func_end   (rule 25)

    ID  	shift, and go to state 8

    id  	go to state 21



state 14

    exp  ->  id . EQUAL exp_type_1   (rule 61)
    exp  ->  id . br_list1 EQUAL exp_type_1   (rule 62)

    LBP 	shift, and go to state 22
    EQUAL	shift, and go to state 23

    br_list1	go to state 24



state 15

    decl  ->  func_decl .   (rule 7)

    $default	reduce using rule 7 (decl)



state 16

    decl  ->  exp . SEMI   (rule 9)

    SEMI	shift, and go to state 25



state 17

    grammar_start  ->  libraries decls INT MAIN . LB RB lcf stmts rcf   (rule 1)

    LB  	shift, and go to state 26



state 18

    var_decl  ->  type var_list . SEMI   (rule 10)
    var_list  ->  var_list . COMMA var   (rule 15)

    SEMI	shift, and go to state 27
    COMMA	shift, and go to state 28



state 19

    var_decl  ->  type var . EQUAL exp_type_1 SEMI   (rule 11)
    var_list  ->  var .   (rule 16)

    EQUAL	shift, and go to state 29

    $default	reduce using rule 16 (var_list)



state 20

    var  ->  id .   (rule 17)
    var  ->  id . br_list   (rule 18)
    func_decl  ->  type id . lbf decl_plist RB lcf body rcf func_end   (rule 24)

    LBP 	shift, and go to state 30
    LB  	shift, and go to state 31

    $default	reduce using rule 17 (var)

    br_list	go to state 32
    lbf 	go to state 33



state 21

    func_decl  ->  void id . lbf decl_plist RB lcf body rcf func_end   (rule 25)

    LB  	shift, and go to state 31

    lbf 	go to state 34



state 22

    br_list1  ->  LBP . exp_type_1 RBP   (rule 22)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 41
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 23

    exp  ->  id EQUAL . exp_type_1   (rule 61)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 53
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 24

    br_list1  ->  br_list1 . LBP exp_type_1 RBP   (rule 23)
    exp  ->  id br_list1 . EQUAL exp_type_1   (rule 62)

    LBP 	shift, and go to state 54
    EQUAL	shift, and go to state 55



state 25

    decl  ->  exp SEMI .   (rule 9)

    $default	reduce using rule 9 (decl)



state 26

    grammar_start  ->  libraries decls INT MAIN LB . RB lcf stmts rcf   (rule 1)

    RB  	shift, and go to state 56



state 27

    var_decl  ->  type var_list SEMI .   (rule 10)

    $default	reduce using rule 10 (var_decl)



state 28

    var_list  ->  var_list COMMA . var   (rule 15)

    ID  	shift, and go to state 8

    var 	go to state 57
    id  	go to state 58



state 29

    var_decl  ->  type var EQUAL . exp_type_1 SEMI   (rule 11)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 59
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 30

    br_list  ->  LBP . intg RBP   (rule 20)

    SUB 	shift, and go to state 60
    INTEGERS	shift, and go to state 37

    intg	go to state 61



state 31

    lbf  ->  LB .   (rule 26)

    $default	reduce using rule 26 (lbf)



state 32

    var  ->  id br_list .   (rule 18)
    br_list  ->  br_list . LBP intg RBP   (rule 21)

    LBP 	shift, and go to state 62

    $default	reduce using rule 18 (var)



state 33

    func_decl  ->  type id lbf . decl_plist RB lcf body rcf func_end   (rule 24)

    $default	reduce using rule 30 (@1)

    decl_plist	go to state 63
    @1  	go to state 64



state 34

    func_decl  ->  void id lbf . decl_plist RB lcf body rcf func_end   (rule 25)

    $default	reduce using rule 30 (@1)

    decl_plist	go to state 65
    @1  	go to state 64



state 35

    unary_operator  ->  ADD . ADD   (rule 103)

    ADD 	shift, and go to state 66



state 36

    intg  ->  SUB . INTEGERS   (rule 88)
    floats  ->  SUB . FLOATING_POINTS   (rule 90)
    unary_operator  ->  SUB . SUB   (rule 102)

    SUB 	shift, and go to state 67
    INTEGERS	shift, and go to state 68
    FLOATING_POINTS	shift, and go to state 69



state 37

    intg  ->  INTEGERS .   (rule 87)

    $default	reduce using rule 87 (intg)



state 38

    floats  ->  FLOATING_POINTS .   (rule 89)

    $default	reduce using rule 89 (floats)



state 39

    term  ->  LB . exp_type_1 RB   (rule 75)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 70
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 40

    term  ->  id .   (rule 78)
    term  ->  id . br_list1   (rule 79)
    func_call  ->  id . LB args RB   (rule 80)

    LBP 	shift, and go to state 22
    LB  	shift, and go to state 71

    $default	reduce using rule 78 (term)

    br_list1	go to state 72



state 41

    br_list1  ->  LBP exp_type_1 . RBP   (rule 22)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    RBP 	shift, and go to state 73
    OR  	shift, and go to state 74



state 42

    exp_type_1  ->  exp_type_2 .   (rule 64)
    exp_type_2  ->  exp_type_2 . AND exp_type_3   (rule 65)

    AND 	shift, and go to state 75

    $default	reduce using rule 64 (exp_type_1)



state 43

    exp_type_2  ->  exp_type_3 .   (rule 66)
    exp_type_3  ->  exp_type_3 . relation_op arith_exp_type_1   (rule 67)

    GT  	shift, and go to state 76
    LT  	shift, and go to state 77
    GE  	shift, and go to state 78
    LE  	shift, and go to state 79
    EQ  	shift, and go to state 80
    NE  	shift, and go to state 81

    $default	reduce using rule 66 (exp_type_2)

    relation_op	go to state 82



state 44

    exp_type_3  ->  arith_exp_type_1 .   (rule 68)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 69)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 68 (exp_type_3)

    plus_minus_op	go to state 85



state 45

    arith_exp_type_1  ->  arith_exp_type_2 .   (rule 70)
    arith_exp_type_2  ->  arith_exp_type_2 . mul_div_op unary_exp   (rule 71)

    MUL 	shift, and go to state 86
    DIV 	shift, and go to state 87
    MOD 	shift, and go to state 88

    $default	reduce using rule 70 (arith_exp_type_1)

    mul_div_op	go to state 89



state 46

    arith_exp_type_2  ->  unary_exp .   (rule 72)

    $default	reduce using rule 72 (arith_exp_type_2)



state 47

    unary_exp  ->  term .   (rule 74)

    $default	reduce using rule 74 (unary_exp)



state 48

    term  ->  func_call .   (rule 76)

    $default	reduce using rule 76 (term)



state 49

    term  ->  consts .   (rule 77)

    $default	reduce using rule 77 (term)



state 50

    consts  ->  intg .   (rule 85)

    $default	reduce using rule 85 (consts)



state 51

    consts  ->  floats .   (rule 86)

    $default	reduce using rule 86 (consts)



state 52

    unary_exp  ->  unary_operator . term   (rule 73)

    SUB 	shift, and go to state 90
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    term	go to state 91
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51



state 53

    exp  ->  id EQUAL exp_type_1 .   (rule 61)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74

    $default	reduce using rule 61 (exp)



state 54

    br_list1  ->  br_list1 LBP . exp_type_1 RBP   (rule 23)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 92
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 55

    exp  ->  id br_list1 EQUAL . exp_type_1   (rule 62)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 93
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 56

    grammar_start  ->  libraries decls INT MAIN LB RB . lcf stmts rcf   (rule 1)

    LC  	shift, and go to state 94

    lcf 	go to state 95



state 57

    var_list  ->  var_list COMMA var .   (rule 15)

    $default	reduce using rule 15 (var_list)



state 58

    var  ->  id .   (rule 17)
    var  ->  id . br_list   (rule 18)

    LBP 	shift, and go to state 30

    $default	reduce using rule 17 (var)

    br_list	go to state 32



state 59

    var_decl  ->  type var EQUAL exp_type_1 . SEMI   (rule 11)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74
    SEMI	shift, and go to state 96



state 60

    intg  ->  SUB . INTEGERS   (rule 88)

    INTEGERS	shift, and go to state 68



state 61

    br_list  ->  LBP intg . RBP   (rule 20)

    RBP 	shift, and go to state 97



state 62

    br_list  ->  br_list LBP . intg RBP   (rule 21)

    SUB 	shift, and go to state 60
    INTEGERS	shift, and go to state 37

    intg	go to state 98



state 63

    func_decl  ->  type id lbf decl_plist . RB lcf body rcf func_end   (rule 24)

    RB  	shift, and go to state 99



state 64

    decl_plist  ->  @1 . decl_pl   (rule 31)

    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7

    type	go to state 101
    decl_pl	go to state 102
    decl_param	go to state 103



state 65

    func_decl  ->  void id lbf decl_plist . RB lcf body rcf func_end   (rule 25)

    RB  	shift, and go to state 104



state 66

    unary_operator  ->  ADD ADD .   (rule 103)

    $default	reduce using rule 103 (unary_operator)



state 67

    unary_operator  ->  SUB SUB .   (rule 102)

    $default	reduce using rule 102 (unary_operator)



state 68

    intg  ->  SUB INTEGERS .   (rule 88)

    $default	reduce using rule 88 (intg)



state 69

    floats  ->  SUB FLOATING_POINTS .   (rule 90)

    $default	reduce using rule 90 (floats)



state 70

    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)
    term  ->  LB exp_type_1 . RB   (rule 75)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 105



state 71

    func_call  ->  id LB . args RB   (rule 80)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    $default	reduce using rule 82 (args)

    id  	go to state 40
    arith_exp_type_1	go to state 106
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    args	go to state 107
    args_list	go to state 108
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 72

    br_list1  ->  br_list1 . LBP exp_type_1 RBP   (rule 23)
    term  ->  id br_list1 .   (rule 79)

    LBP 	shift, and go to state 54

    $default	reduce using rule 79 (term)



state 73

    br_list1  ->  LBP exp_type_1 RBP .   (rule 22)

    $default	reduce using rule 22 (br_list1)



state 74

    exp_type_1  ->  exp_type_1 OR . exp_type_2   (rule 63)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_2	go to state 109
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 75

    exp_type_2  ->  exp_type_2 AND . exp_type_3   (rule 65)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_3	go to state 110
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 76

    relation_op  ->  GT .   (rule 96)

    $default	reduce using rule 96 (relation_op)



state 77

    relation_op  ->  LT .   (rule 97)

    $default	reduce using rule 97 (relation_op)



state 78

    relation_op  ->  GE .   (rule 98)

    $default	reduce using rule 98 (relation_op)



state 79

    relation_op  ->  LE .   (rule 99)

    $default	reduce using rule 99 (relation_op)



state 80

    relation_op  ->  EQ .   (rule 100)

    $default	reduce using rule 100 (relation_op)



state 81

    relation_op  ->  NE .   (rule 101)

    $default	reduce using rule 101 (relation_op)



state 82

    exp_type_3  ->  exp_type_3 relation_op . arith_exp_type_1   (rule 67)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_1	go to state 111
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 83

    plus_minus_op  ->  ADD .   (rule 91)

    $default	reduce using rule 91 (plus_minus_op)



state 84

    plus_minus_op  ->  SUB .   (rule 92)

    $default	reduce using rule 92 (plus_minus_op)



state 85

    arith_exp_type_1  ->  arith_exp_type_1 plus_minus_op . arith_exp_type_2   (rule 69)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_2	go to state 112
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 86

    mul_div_op  ->  MUL .   (rule 93)

    $default	reduce using rule 93 (mul_div_op)



state 87

    mul_div_op  ->  DIV .   (rule 94)

    $default	reduce using rule 94 (mul_div_op)



state 88

    mul_div_op  ->  MOD .   (rule 95)

    $default	reduce using rule 95 (mul_div_op)



state 89

    arith_exp_type_2  ->  arith_exp_type_2 mul_div_op . unary_exp   (rule 71)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    unary_exp	go to state 113
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 90

    intg  ->  SUB . INTEGERS   (rule 88)
    floats  ->  SUB . FLOATING_POINTS   (rule 90)

    INTEGERS	shift, and go to state 68
    FLOATING_POINTS	shift, and go to state 69



state 91

    unary_exp  ->  unary_operator term .   (rule 73)

    $default	reduce using rule 73 (unary_exp)



state 92

    br_list1  ->  br_list1 LBP exp_type_1 . RBP   (rule 23)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    RBP 	shift, and go to state 114
    OR  	shift, and go to state 74



state 93

    exp  ->  id br_list1 EQUAL exp_type_1 .   (rule 62)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74

    $default	reduce using rule 62 (exp)



state 94

    lcf  ->  LC .   (rule 27)

    $default	reduce using rule 27 (lcf)



state 95

    grammar_start  ->  libraries decls INT MAIN LB RB lcf . stmts rcf   (rule 1)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122

    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 127
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 96

    var_decl  ->  type var EQUAL exp_type_1 SEMI .   (rule 11)

    $default	reduce using rule 11 (var_decl)



state 97

    br_list  ->  LBP intg RBP .   (rule 20)

    $default	reduce using rule 20 (br_list)



state 98

    br_list  ->  br_list LBP intg . RBP   (rule 21)

    RBP 	shift, and go to state 134



state 99

    func_decl  ->  type id lbf decl_plist RB . lcf body rcf func_end   (rule 24)

    LC  	shift, and go to state 94

    lcf 	go to state 135



state 100

    type  ->  INT .   (rule 12)

    $default	reduce using rule 12 (type)



state 101

    decl_param  ->  type . var   (rule 35)

    ID  	shift, and go to state 8

    var 	go to state 136
    id  	go to state 58



state 102

    decl_plist  ->  @1 decl_pl .   (rule 31)

    $default	reduce using rule 31 (decl_plist)



state 103

    decl_pl  ->  decl_param . COMMA decl_pl   (rule 33)
    decl_pl  ->  decl_param .   (rule 34)

    COMMA	shift, and go to state 137

    $default	reduce using rule 34 (decl_pl)



state 104

    func_decl  ->  void id lbf decl_plist RB . lcf body rcf func_end   (rule 25)

    LC  	shift, and go to state 94

    lcf 	go to state 138



state 105

    term  ->  LB exp_type_1 RB .   (rule 75)

    $default	reduce using rule 75 (term)



state 106

    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 69)
    args_list  ->  arith_exp_type_1 .   (rule 84)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 84 (args_list)

    plus_minus_op	go to state 85



state 107

    func_call  ->  id LB args . RB   (rule 80)

    RB  	shift, and go to state 139



state 108

    args  ->  args_list .   (rule 81)
    args_list  ->  args_list . COMMA arith_exp_type_1   (rule 83)

    COMMA	shift, and go to state 140

    $default	reduce using rule 81 (args)



state 109

    exp_type_1  ->  exp_type_1 OR exp_type_2 .   (rule 63)
    exp_type_2  ->  exp_type_2 . AND exp_type_3   (rule 65)

    AND 	shift, and go to state 75

    $default	reduce using rule 63 (exp_type_1)



state 110

    exp_type_2  ->  exp_type_2 AND exp_type_3 .   (rule 65)
    exp_type_3  ->  exp_type_3 . relation_op arith_exp_type_1   (rule 67)

    GT  	shift, and go to state 76
    LT  	shift, and go to state 77
    GE  	shift, and go to state 78
    LE  	shift, and go to state 79
    EQ  	shift, and go to state 80
    NE  	shift, and go to state 81

    $default	reduce using rule 65 (exp_type_2)

    relation_op	go to state 82



state 111

    exp_type_3  ->  exp_type_3 relation_op arith_exp_type_1 .   (rule 67)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 69)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 67 (exp_type_3)

    plus_minus_op	go to state 85



state 112

    arith_exp_type_1  ->  arith_exp_type_1 plus_minus_op arith_exp_type_2 .   (rule 69)
    arith_exp_type_2  ->  arith_exp_type_2 . mul_div_op unary_exp   (rule 71)

    MUL 	shift, and go to state 86
    DIV 	shift, and go to state 87
    MOD 	shift, and go to state 88

    $default	reduce using rule 69 (arith_exp_type_1)

    mul_div_op	go to state 89



state 113

    arith_exp_type_2  ->  arith_exp_type_2 mul_div_op unary_exp .   (rule 71)

    $default	reduce using rule 71 (arith_exp_type_2)



state 114

    br_list1  ->  br_list1 LBP exp_type_1 RBP .   (rule 23)

    $default	reduce using rule 23 (br_list1)



state 115

    stmt  ->  error . SEMI   (rule 52)

    SEMI	shift, and go to state 141



state 116

    return_exp  ->  RETURN .   (rule 59)
    return_exp  ->  RETURN . exp_type_1   (rule 60)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    $default	reduce using rule 59 (return_exp)

    id  	go to state 40
    exp_type_1	go to state 142
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 117

    stmt  ->  IF . LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF . LB exp_type_1 RB lcf stmts rcf   (rule 46)

    LB  	shift, and go to state 143



state 118

    stmt  ->  FOR . LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    LB  	shift, and go to state 144



state 119

    stmt  ->  WHILE . LB exp_type_1 RB lcf stmts rcf   (rule 44)

    LB  	shift, and go to state 145



state 120

    break  ->  BREAK .   (rule 53)

    $default	reduce using rule 53 (break)



state 121

    continue  ->  CONTINUE .   (rule 54)

    $default	reduce using rule 54 (continue)



state 122

    stmt  ->  SWITCH . LB exp_type_1 RB LC case_exp default_exp RC   (rule 47)

    LB  	shift, and go to state 146



state 123

    stmt  ->  var_decl .   (rule 40)

    $default	reduce using rule 40 (stmt)



state 124

    var_decl  ->  type . var_list SEMI   (rule 10)
    var_decl  ->  type . var EQUAL exp_type_1 SEMI   (rule 11)

    ID  	shift, and go to state 8

    var_list	go to state 18
    var 	go to state 19
    id  	go to state 58



state 125

    exp  ->  id . EQUAL exp_type_1   (rule 61)
    exp  ->  id . br_list1 EQUAL exp_type_1   (rule 62)
    term  ->  id .   (rule 78)
    term  ->  id . br_list1   (rule 79)
    func_call  ->  id . LB args RB   (rule 80)

    LBP 	shift, and go to state 22
    LB  	shift, and go to state 71
    EQUAL	shift, and go to state 23

    $default	reduce using rule 78 (term)

    br_list1	go to state 147



state 126

    stmt  ->  lcf . body rcf   (rule 51)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122


    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    body	go to state 148
    stmts	go to state 149
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 127

    grammar_start  ->  libraries decls INT MAIN LB RB lcf stmts . rcf   (rule 1)

    RC  	shift, and go to state 150

    rcf 	go to state 151



state 128

    stmts  ->  stmt . stmts   (rule 38)
    stmts  ->  stmt .   (rule 39)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122


    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 152
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 129

    stmt  ->  break . SEMI   (rule 49)

    SEMI	shift, and go to state 153



state 130

    stmt  ->  continue . SEMI   (rule 48)

    SEMI	shift, and go to state 154



state 131

    stmt  ->  return_exp . SEMI   (rule 50)

    SEMI	shift, and go to state 155



state 132

    stmt  ->  exp . SEMI   (rule 41)

    SEMI	shift, and go to state 156



state 133

    stmt  ->  exp_type_1 . SEMI   (rule 42)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74
    SEMI	shift, and go to state 157



state 134

    br_list  ->  br_list LBP intg RBP .   (rule 21)

    $default	reduce using rule 21 (br_list)



state 135

    func_decl  ->  type id lbf decl_plist RB lcf . body rcf func_end   (rule 24)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122


    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    body	go to state 158
    stmts	go to state 149
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 136

    decl_param  ->  type var .   (rule 35)

    $default	reduce using rule 35 (decl_param)



state 137

    decl_pl  ->  decl_param COMMA . decl_pl   (rule 33)

    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7

    type	go to state 101
    decl_pl	go to state 159
    decl_param	go to state 103



state 138

    func_decl  ->  void id lbf decl_plist RB lcf . body rcf func_end   (rule 25)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122


    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    body	go to state 160
    stmts	go to state 149
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 139

    func_call  ->  id LB args RB .   (rule 80)

    $default	reduce using rule 80 (func_call)



state 140

    args_list  ->  args_list COMMA . arith_exp_type_1   (rule 83)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_1	go to state 161
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 141

    stmt  ->  error SEMI .   (rule 52)

    $default	reduce using rule 52 (stmt)



state 142

    return_exp  ->  RETURN exp_type_1 .   (rule 60)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74

    $default	reduce using rule 60 (return_exp)



state 143

    stmt  ->  IF LB . exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB . exp_type_1 RB lcf stmts rcf   (rule 46)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 162
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 144

    stmt  ->  FOR LB . exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    ID  	shift, and go to state 8

    id  	go to state 14
    exp 	go to state 163



state 145

    stmt  ->  WHILE LB . exp_type_1 RB lcf stmts rcf   (rule 44)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 164
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 146

    stmt  ->  SWITCH LB . exp_type_1 RB LC case_exp default_exp RC   (rule 47)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 165
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 147

    br_list1  ->  br_list1 . LBP exp_type_1 RBP   (rule 23)
    exp  ->  id br_list1 . EQUAL exp_type_1   (rule 62)
    term  ->  id br_list1 .   (rule 79)

    LBP 	shift, and go to state 54
    EQUAL	shift, and go to state 55

    $default	reduce using rule 79 (term)



state 148

    stmt  ->  lcf body . rcf   (rule 51)

    RC  	shift, and go to state 150

    rcf 	go to state 166



state 149

    body  ->  stmts .   (rule 36)

    $default	reduce using rule 36 (body)



state 150

    rcf  ->  RC .   (rule 28)

    $default	reduce using rule 28 (rcf)



state 151

    grammar_start  ->  libraries decls INT MAIN LB RB lcf stmts rcf .   (rule 1)

    $default	reduce using rule 1 (grammar_start)



state 152

    stmts  ->  stmt stmts .   (rule 38)

    $default	reduce using rule 38 (stmts)



state 153

    stmt  ->  break SEMI .   (rule 49)

    $default	reduce using rule 49 (stmt)



state 154

    stmt  ->  continue SEMI .   (rule 48)

    $default	reduce using rule 48 (stmt)



state 155

    stmt  ->  return_exp SEMI .   (rule 50)

    $default	reduce using rule 50 (stmt)



state 156

    stmt  ->  exp SEMI .   (rule 41)

    $default	reduce using rule 41 (stmt)



state 157

    stmt  ->  exp_type_1 SEMI .   (rule 42)

    $default	reduce using rule 42 (stmt)



state 158

    func_decl  ->  type id lbf decl_plist RB lcf body . rcf func_end   (rule 24)

    RC  	shift, and go to state 150

    rcf 	go to state 167



state 159

    decl_pl  ->  decl_param COMMA decl_pl .   (rule 33)

    $default	reduce using rule 33 (decl_pl)



state 160

    func_decl  ->  void id lbf decl_plist RB lcf body . rcf func_end   (rule 25)

    RC  	shift, and go to state 150

    rcf 	go to state 168



state 161

    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 69)
    args_list  ->  args_list COMMA arith_exp_type_1 .   (rule 83)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 83 (args_list)

    plus_minus_op	go to state 85



state 162

    stmt  ->  IF LB exp_type_1 . RB lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 . RB lcf stmts rcf   (rule 46)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 169



state 163

    stmt  ->  FOR LB exp . SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    SEMI	shift, and go to state 170



state 164

    stmt  ->  WHILE LB exp_type_1 . RB lcf stmts rcf   (rule 44)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 171



state 165

    stmt  ->  SWITCH LB exp_type_1 . RB LC case_exp default_exp RC   (rule 47)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 172



state 166

    stmt  ->  lcf body rcf .   (rule 51)

    $default	reduce using rule 51 (stmt)



state 167

    func_decl  ->  type id lbf decl_plist RB lcf body rcf . func_end   (rule 24)

    $default	reduce using rule 29 (func_end)

    func_end	go to state 173



state 168

    func_decl  ->  void id lbf decl_plist RB lcf body rcf . func_end   (rule 25)

    $default	reduce using rule 29 (func_end)

    func_end	go to state 174



state 169

    stmt  ->  IF LB exp_type_1 RB . lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB . lcf stmts rcf   (rule 46)

    LC  	shift, and go to state 94

    lcf 	go to state 175



state 170

    stmt  ->  FOR LB exp SEMI . exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 176
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 171

    stmt  ->  WHILE LB exp_type_1 RB . lcf stmts rcf   (rule 44)

    LC  	shift, and go to state 94

    lcf 	go to state 177



state 172

    stmt  ->  SWITCH LB exp_type_1 RB . LC case_exp default_exp RC   (rule 47)

    LC  	shift, and go to state 178



state 173

    func_decl  ->  type id lbf decl_plist RB lcf body rcf func_end .   (rule 24)

    $default	reduce using rule 24 (func_decl)



state 174

    func_decl  ->  void id lbf decl_plist RB lcf body rcf func_end .   (rule 25)

    $default	reduce using rule 25 (func_decl)



state 175

    stmt  ->  IF LB exp_type_1 RB lcf . stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB lcf . stmts rcf   (rule 46)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122

    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 179
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 176

    stmt  ->  FOR LB exp SEMI exp_type_1 . SEMI exp_type_1 RB lcf stmts rcf   (rule 43)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74
    SEMI	shift, and go to state 180



state 177

    stmt  ->  WHILE LB exp_type_1 RB lcf . stmts rcf   (rule 44)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122

    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 181
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 178

    stmt  ->  SWITCH LB exp_type_1 RB LC . case_exp default_exp RC   (rule 47)

    CASE	shift, and go to state 182

    $default	reduce using rule 56 (case_exp)

    case_exp	go to state 183



state 179

    stmt  ->  IF LB exp_type_1 RB lcf stmts . rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB lcf stmts . rcf   (rule 46)

    RC  	shift, and go to state 150

    rcf 	go to state 184



state 180

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI . exp_type_1 RB lcf stmts rcf   (rule 43)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 185
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 181

    stmt  ->  WHILE LB exp_type_1 RB lcf stmts . rcf   (rule 44)

    RC  	shift, and go to state 150

    rcf 	go to state 186



state 182

    case_exp  ->  CASE . LB arith_exp_type_1 RB COLON lcf stmts rcf case_exp   (rule 55)

    LB  	shift, and go to state 187



state 183

    stmt  ->  SWITCH LB exp_type_1 RB LC case_exp . default_exp RC   (rule 47)

    DEFAULT	shift, and go to state 188

    $default	reduce using rule 58 (default_exp)

    default_exp	go to state 189



state 184

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf . ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf .   (rule 46)

    ELSE	shift, and go to state 190

    $default	reduce using rule 46 (stmt)



state 185

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 . RB lcf stmts rcf   (rule 43)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 63)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 191



state 186

    stmt  ->  WHILE LB exp_type_1 RB lcf stmts rcf .   (rule 44)

    $default	reduce using rule 44 (stmt)



state 187

    case_exp  ->  CASE LB . arith_exp_type_1 RB COLON lcf stmts rcf case_exp   (rule 55)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_1	go to state 192
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 188

    default_exp  ->  DEFAULT . COLON lcf stmts rcf   (rule 57)

    COLON	shift, and go to state 193



state 189

    stmt  ->  SWITCH LB exp_type_1 RB LC case_exp default_exp . RC   (rule 47)

    RC  	shift, and go to state 194



state 190

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE . lcf stmts rcf   (rule 45)

    LC  	shift, and go to state 94

    lcf 	go to state 195



state 191

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB . lcf stmts rcf   (rule 43)

    LC  	shift, and go to state 94

    lcf 	go to state 196



state 192

    case_exp  ->  CASE LB arith_exp_type_1 . RB COLON lcf stmts rcf case_exp   (rule 55)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 69)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84
    RB  	shift, and go to state 197

    plus_minus_op	go to state 85



state 193

    default_exp  ->  DEFAULT COLON . lcf stmts rcf   (rule 57)

    LC  	shift, and go to state 94

    lcf 	go to state 198



state 194

    stmt  ->  SWITCH LB exp_type_1 RB LC case_exp default_exp RC .   (rule 47)

    $default	reduce using rule 47 (stmt)



state 195

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE lcf . stmts rcf   (rule 45)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122

    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 199
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 196

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf . stmts rcf   (rule 43)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122

    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 200
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 197

    case_exp  ->  CASE LB arith_exp_type_1 RB . COLON lcf stmts rcf case_exp   (rule 55)

    COLON	shift, and go to state 201



state 198

    default_exp  ->  DEFAULT COLON lcf . stmts rcf   (rule 57)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122

    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 202
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 199

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts . rcf   (rule 45)

    RC  	shift, and go to state 150

    rcf 	go to state 203



state 200

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts . rcf   (rule 43)

    RC  	shift, and go to state 150

    rcf 	go to state 204



state 201

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON . lcf stmts rcf case_exp   (rule 55)

    LC  	shift, and go to state 94

    lcf 	go to state 205



state 202

    default_exp  ->  DEFAULT COLON lcf stmts . rcf   (rule 57)

    RC  	shift, and go to state 150

    rcf 	go to state 206



state 203

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf .   (rule 45)

    $default	reduce using rule 45 (stmt)



state 204

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf .   (rule 43)

    $default	reduce using rule 43 (stmt)



state 205

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf . stmts rcf case_exp   (rule 55)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    RETURN	shift, and go to state 116
    IF  	shift, and go to state 117
    FOR 	shift, and go to state 118
    WHILE	shift, and go to state 119
    BREAK	shift, and go to state 120
    CONTINUE	shift, and go to state 121
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 122

    var_decl	go to state 123
    type	go to state 124
    id  	go to state 125
    lcf 	go to state 126
    stmts	go to state 207
    stmt	go to state 128
    break	go to state 129
    continue	go to state 130
    return_exp	go to state 131
    exp 	go to state 132
    exp_type_1	go to state 133
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 206

    default_exp  ->  DEFAULT COLON lcf stmts rcf .   (rule 57)

    $default	reduce using rule 57 (default_exp)



state 207

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf stmts . rcf case_exp   (rule 55)

    RC  	shift, and go to state 150

    rcf 	go to state 208



state 208

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf stmts rcf . case_exp   (rule 55)

    CASE	shift, and go to state 182

    $default	reduce using rule 56 (case_exp)

    case_exp	go to state 209



state 209

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf stmts rcf case_exp .   (rule 55)

    $default	reduce using rule 55 (case_exp)



state 210

    $   	go to state 211



state 211

    $   	go to state 212



state 212

    $default	accept
