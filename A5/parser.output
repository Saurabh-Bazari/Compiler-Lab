
Grammar
rule 1    grammar_start -> libraries decls INT MAIN LB RB lcf stmts rcf
rule 2    grammar_start -> error
rule 3    libraries -> LIBRARY libraries
rule 4    libraries -> LIBRARY
rule 5    decls -> decls decl
rule 6    decls ->		/* empty */
rule 7    decl -> func_decl
rule 8    decl -> var_decl
rule 9    decl -> exp SEMI
rule 10   var_decl -> type var_list SEMI
rule 11   var_decl -> type var EQUAL exp_type_1 SEMI
rule 12   type -> INT
rule 13   type -> FLOAT
rule 14   void -> VOID
rule 15   var_list -> var_list COMMA var
rule 16   var_list -> var
rule 17   var -> id
rule 18   var -> id br_list
rule 19   id -> ID
rule 20   br_list -> LBP intg RBP
rule 21   br_list -> br_list LBP intg RBP
rule 22   br_list1 -> LBP exp_type_1 RBP
rule 23   br_list1 -> br_list1 LBP exp_type_1 RBP
rule 24   func_decl -> type id lbf decl_plist RB lcf body rcf func_end
rule 25   func_decl -> void id lbf decl_plist RB lcf body rcf func_end
rule 26   lbf -> LB
rule 27   lcf -> LC
rule 28   rcf -> RC
rule 29   func_end ->		/* empty */
rule 30   @1 ->		/* empty */
rule 31   decl_plist -> @1 decl_pl
rule 32   decl_plist ->		/* empty */
rule 33   decl_pl -> decl_param COMMA decl_pl
rule 34   decl_pl -> decl_param
rule 35   decl_param -> type var
rule 36   body -> stmts
rule 37   body ->		/* empty */
rule 38   stmts -> stmt stmts
rule 39   stmts -> stmt
rule 40   stmt -> var_decl
rule 41   stmt -> exp SEMI
rule 42   stmt -> exp_type_1 SEMI
rule 43   stmt -> FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf
rule 44   stmt -> WHILE LB exp_type_1 RB lcf stmts rcf
rule 45   stmt -> IF LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf
rule 46   stmt -> IF LB exp_type_1 RB lcf stmts rcf
rule 47   stmt -> SWITCH LB exp_type_1 RB LC case_exp default_exp RC
rule 48   stmt -> continue SEMI
rule 49   stmt -> break SEMI
rule 50   stmt -> return_exp SEMI
rule 51   stmt -> lcf body rcf
rule 52   stmt -> PRINT LB args1 RB SEMI
rule 53   stmt -> READ LB args RB SEMI
rule 54   stmt -> error SEMI
rule 55   args1 -> args_list1
rule 56   args1 ->		/* empty */
rule 57   args_list1 -> args_list1 COMMA arith_exp_type_1
rule 58   args_list1 -> arith_exp_type_1
rule 59   args_list1 -> args_list1 COMMA string
rule 60   args_list1 -> string
rule 61   string -> STRING
rule 62   break -> BREAK
rule 63   continue -> CONTINUE
rule 64   case_exp -> CASE LB arith_exp_type_1 RB COLON lcf stmts rcf case_exp
rule 65   case_exp ->		/* empty */
rule 66   default_exp -> DEFAULT COLON lcf stmts rcf
rule 67   default_exp ->		/* empty */
rule 68   return_exp -> RETURN
rule 69   return_exp -> RETURN exp_type_1
rule 70   exp -> id EQUAL exp_type_1
rule 71   exp -> id br_list1 EQUAL exp_type_1
rule 72   exp_type_1 -> exp_type_1 OR exp_type_2
rule 73   exp_type_1 -> exp_type_2
rule 74   exp_type_2 -> exp_type_2 AND exp_type_3
rule 75   exp_type_2 -> exp_type_3
rule 76   exp_type_3 -> exp_type_3 relation_op arith_exp_type_1
rule 77   exp_type_3 -> arith_exp_type_1
rule 78   arith_exp_type_1 -> arith_exp_type_1 plus_minus_op arith_exp_type_2
rule 79   arith_exp_type_1 -> arith_exp_type_2
rule 80   arith_exp_type_2 -> arith_exp_type_2 mul_div_op unary_exp
rule 81   arith_exp_type_2 -> unary_exp
rule 82   unary_exp -> unary_operator term
rule 83   unary_exp -> term
rule 84   term -> LB exp_type_1 RB
rule 85   term -> func_call
rule 86   term -> consts
rule 87   term -> id
rule 88   term -> id br_list1
rule 89   func_call -> id LB args RB
rule 90   args -> args_list
rule 91   args ->		/* empty */
rule 92   args_list -> args_list COMMA arith_exp_type_1
rule 93   args_list -> arith_exp_type_1
rule 94   consts -> intg
rule 95   consts -> floats
rule 96   intg -> INTEGERS
rule 97   intg -> SUB INTEGERS
rule 98   floats -> FLOATING_POINTS
rule 99   floats -> SUB FLOATING_POINTS
rule 100  plus_minus_op -> ADD
rule 101  plus_minus_op -> SUB
rule 102  mul_div_op -> MUL
rule 103  mul_div_op -> DIV
rule 104  mul_div_op -> MOD
rule 105  relation_op -> GT
rule 106  relation_op -> LT
rule 107  relation_op -> GE
rule 108  relation_op -> LE
rule 109  relation_op -> EQ
rule 110  relation_op -> NE
rule 111  unary_operator -> SUB SUB
rule 112  unary_operator -> ADD ADD

Terminals, with rules where they appear

$ (-1)
error (256) 2 54
ADD (258) 100 112
SUB (259) 97 99 101 111
MUL (260) 102
DIV (261) 103
GT (262) 105
LT (263) 106
GE (264) 107
LBP (265) 20 21 22 23
RBP (266) 20 21 22 23
LE (267) 108
EQ (268) 109
NE (269) 110
MAIN (270) 1
INT (271) 1 12
FLOAT (272) 13
PRINT (273) 52
RETURN (274) 68 69
OR (275) 72
AND (276) 74
IF (277) 45 46
FOR (278) 43
READ (279) 53
WHILE (280) 44
ELSE (281) 45
BREAK (282) 62
CONTINUE (283) 63
INTEGERS (284) 96 97
FLOATING_POINTS (285) 98 99
ID (286) 19
SEMI (287) 9 10 11 41 42 43 48 49 50 52 53 54
LC (288) 27 47
RC (289) 28 47
LB (290) 1 26 43 44 45 46 47 52 53 64 84 89
RB (291) 1 24 25 43 44 45 46 47 52 53 64 84 89
COMMA (292) 15 33 57 59 92
EQUAL (293) 11 70 71
MOD (294) 104
LIBRARY (295) 3 4
VOID (296) 14
SWITCH (297) 47
CASE (298) 64
DEFAULT (299) 66
COLON (300) 64 66
STRING (301) 61

Nonterminals, with rules where they appear

grammar_start (47)
    on left: 1 2
libraries (48)
    on left: 3 4, on right: 1 3
decls (49)
    on left: 5 6, on right: 1 5
decl (50)
    on left: 7 8 9, on right: 5
var_decl (51)
    on left: 10 11, on right: 8 40
type (52)
    on left: 12 13, on right: 10 11 24 35
void (53)
    on left: 14, on right: 25
var_list (54)
    on left: 15 16, on right: 10 15
var (55)
    on left: 17 18, on right: 11 15 16 35
id (56)
    on left: 19, on right: 17 18 24 25 70 71 87 88 89
br_list (57)
    on left: 20 21, on right: 18 21
br_list1 (58)
    on left: 22 23, on right: 23 71 88
func_decl (59)
    on left: 24 25, on right: 7
lbf (60)
    on left: 26, on right: 24 25
lcf (61)
    on left: 27, on right: 1 24 25 43 44 45 46 51 64 66
rcf (62)
    on left: 28, on right: 1 24 25 43 44 45 46 51 64 66
func_end (63)
    on left: 29, on right: 24 25
decl_plist (64)
    on left: 31 32, on right: 24 25
@1 (65)
    on left: 30, on right: 31
decl_pl (66)
    on left: 33 34, on right: 31 33
decl_param (67)
    on left: 35, on right: 33 34
body (68)
    on left: 36 37, on right: 24 25 51
stmts (69)
    on left: 38 39, on right: 1 36 38 43 44 45 46 64 66
stmt (70)
    on left: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54,
    on right: 38 39
args1 (71)
    on left: 55 56, on right: 52
args_list1 (72)
    on left: 57 58 59 60, on right: 55 57 59
string (73)
    on left: 61, on right: 59 60
break (74)
    on left: 62, on right: 49
continue (75)
    on left: 63, on right: 48
case_exp (76)
    on left: 64 65, on right: 47 64
default_exp (77)
    on left: 66 67, on right: 47
return_exp (78)
    on left: 68 69, on right: 50
exp (79)
    on left: 70 71, on right: 9 41 43
exp_type_1 (80)
    on left: 72 73, on right: 11 22 23 42 43 44 45 46 47 69 70 71 72
    84
exp_type_2 (81)
    on left: 74 75, on right: 72 73 74
exp_type_3 (82)
    on left: 76 77, on right: 74 75 76
arith_exp_type_1 (83)
    on left: 78 79, on right: 57 58 64 76 77 78 92 93
arith_exp_type_2 (84)
    on left: 80 81, on right: 78 79 80
unary_exp (85)
    on left: 82 83, on right: 80 81
term (86)
    on left: 84 85 86 87 88, on right: 82 83
func_call (87)
    on left: 89, on right: 85
args (88)
    on left: 90 91, on right: 53 89
args_list (89)
    on left: 92 93, on right: 90 92
consts (90)
    on left: 94 95, on right: 86
intg (91)
    on left: 96 97, on right: 20 21 94
floats (92)
    on left: 98 99, on right: 95
plus_minus_op (93)
    on left: 100 101, on right: 78
mul_div_op (94)
    on left: 102 103 104, on right: 80
relation_op (95)
    on left: 105 106 107 108 109 110, on right: 76
unary_operator (96)
    on left: 111 112, on right: 82


state 0

    error	shift, and go to state 1
    LIBRARY	shift, and go to state 2

    grammar_start	go to state 227
    libraries	go to state 3



state 1

    grammar_start  ->  error .   (rule 2)

    $default	reduce using rule 2 (grammar_start)



state 2

    libraries  ->  LIBRARY . libraries   (rule 3)
    libraries  ->  LIBRARY .   (rule 4)

    LIBRARY	shift, and go to state 2

    $default	reduce using rule 4 (libraries)

    libraries	go to state 4



state 3

    grammar_start  ->  libraries . decls INT MAIN LB RB lcf stmts rcf   (rule 1)

    $default	reduce using rule 6 (decls)

    decls	go to state 5



state 4

    libraries  ->  LIBRARY libraries .   (rule 3)

    $default	reduce using rule 3 (libraries)



state 5

    grammar_start  ->  libraries decls . INT MAIN LB RB lcf stmts rcf   (rule 1)
    decls  ->  decls . decl   (rule 5)

    INT 	shift, and go to state 6
    FLOAT	shift, and go to state 7
    ID  	shift, and go to state 8
    VOID	shift, and go to state 9

    decl	go to state 10
    var_decl	go to state 11
    type	go to state 12
    void	go to state 13
    id  	go to state 14
    func_decl	go to state 15
    exp 	go to state 16



state 6

    grammar_start  ->  libraries decls INT . MAIN LB RB lcf stmts rcf   (rule 1)
    type  ->  INT .   (rule 12)

    MAIN	shift, and go to state 17

    $default	reduce using rule 12 (type)



state 7

    type  ->  FLOAT .   (rule 13)

    $default	reduce using rule 13 (type)



state 8

    id  ->  ID .   (rule 19)

    $default	reduce using rule 19 (id)



state 9

    void  ->  VOID .   (rule 14)

    $default	reduce using rule 14 (void)



state 10

    decls  ->  decls decl .   (rule 5)

    $default	reduce using rule 5 (decls)



state 11

    decl  ->  var_decl .   (rule 8)

    $default	reduce using rule 8 (decl)



state 12

    var_decl  ->  type . var_list SEMI   (rule 10)
    var_decl  ->  type . var EQUAL exp_type_1 SEMI   (rule 11)
    func_decl  ->  type . id lbf decl_plist RB lcf body rcf func_end   (rule 24)

    ID  	shift, and go to state 8

    var_list	go to state 18
    var 	go to state 19
    id  	go to state 20



state 13

    func_decl  ->  void . id lbf decl_plist RB lcf body rcf func_end   (rule 25)

    ID  	shift, and go to state 8

    id  	go to state 21



state 14

    exp  ->  id . EQUAL exp_type_1   (rule 70)
    exp  ->  id . br_list1 EQUAL exp_type_1   (rule 71)

    LBP 	shift, and go to state 22
    EQUAL	shift, and go to state 23

    br_list1	go to state 24



state 15

    decl  ->  func_decl .   (rule 7)

    $default	reduce using rule 7 (decl)



state 16

    decl  ->  exp . SEMI   (rule 9)

    SEMI	shift, and go to state 25



state 17

    grammar_start  ->  libraries decls INT MAIN . LB RB lcf stmts rcf   (rule 1)

    LB  	shift, and go to state 26



state 18

    var_decl  ->  type var_list . SEMI   (rule 10)
    var_list  ->  var_list . COMMA var   (rule 15)

    SEMI	shift, and go to state 27
    COMMA	shift, and go to state 28



state 19

    var_decl  ->  type var . EQUAL exp_type_1 SEMI   (rule 11)
    var_list  ->  var .   (rule 16)

    EQUAL	shift, and go to state 29

    $default	reduce using rule 16 (var_list)



state 20

    var  ->  id .   (rule 17)
    var  ->  id . br_list   (rule 18)
    func_decl  ->  type id . lbf decl_plist RB lcf body rcf func_end   (rule 24)

    LBP 	shift, and go to state 30
    LB  	shift, and go to state 31

    $default	reduce using rule 17 (var)

    br_list	go to state 32
    lbf 	go to state 33



state 21

    func_decl  ->  void id . lbf decl_plist RB lcf body rcf func_end   (rule 25)

    LB  	shift, and go to state 31

    lbf 	go to state 34



state 22

    br_list1  ->  LBP . exp_type_1 RBP   (rule 22)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 41
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 23

    exp  ->  id EQUAL . exp_type_1   (rule 70)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 53
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 24

    br_list1  ->  br_list1 . LBP exp_type_1 RBP   (rule 23)
    exp  ->  id br_list1 . EQUAL exp_type_1   (rule 71)

    LBP 	shift, and go to state 54
    EQUAL	shift, and go to state 55



state 25

    decl  ->  exp SEMI .   (rule 9)

    $default	reduce using rule 9 (decl)



state 26

    grammar_start  ->  libraries decls INT MAIN LB . RB lcf stmts rcf   (rule 1)

    RB  	shift, and go to state 56



state 27

    var_decl  ->  type var_list SEMI .   (rule 10)

    $default	reduce using rule 10 (var_decl)



state 28

    var_list  ->  var_list COMMA . var   (rule 15)

    ID  	shift, and go to state 8

    var 	go to state 57
    id  	go to state 58



state 29

    var_decl  ->  type var EQUAL . exp_type_1 SEMI   (rule 11)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 59
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 30

    br_list  ->  LBP . intg RBP   (rule 20)

    SUB 	shift, and go to state 60
    INTEGERS	shift, and go to state 37

    intg	go to state 61



state 31

    lbf  ->  LB .   (rule 26)

    $default	reduce using rule 26 (lbf)



state 32

    var  ->  id br_list .   (rule 18)
    br_list  ->  br_list . LBP intg RBP   (rule 21)

    LBP 	shift, and go to state 62

    $default	reduce using rule 18 (var)



state 33

    func_decl  ->  type id lbf . decl_plist RB lcf body rcf func_end   (rule 24)

    $default	reduce using rule 30 (@1)

    decl_plist	go to state 63
    @1  	go to state 64



state 34

    func_decl  ->  void id lbf . decl_plist RB lcf body rcf func_end   (rule 25)

    $default	reduce using rule 30 (@1)

    decl_plist	go to state 65
    @1  	go to state 64



state 35

    unary_operator  ->  ADD . ADD   (rule 112)

    ADD 	shift, and go to state 66



state 36

    intg  ->  SUB . INTEGERS   (rule 97)
    floats  ->  SUB . FLOATING_POINTS   (rule 99)
    unary_operator  ->  SUB . SUB   (rule 111)

    SUB 	shift, and go to state 67
    INTEGERS	shift, and go to state 68
    FLOATING_POINTS	shift, and go to state 69



state 37

    intg  ->  INTEGERS .   (rule 96)

    $default	reduce using rule 96 (intg)



state 38

    floats  ->  FLOATING_POINTS .   (rule 98)

    $default	reduce using rule 98 (floats)



state 39

    term  ->  LB . exp_type_1 RB   (rule 84)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 70
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 40

    term  ->  id .   (rule 87)
    term  ->  id . br_list1   (rule 88)
    func_call  ->  id . LB args RB   (rule 89)

    LBP 	shift, and go to state 22
    LB  	shift, and go to state 71

    $default	reduce using rule 87 (term)

    br_list1	go to state 72



state 41

    br_list1  ->  LBP exp_type_1 . RBP   (rule 22)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    RBP 	shift, and go to state 73
    OR  	shift, and go to state 74



state 42

    exp_type_1  ->  exp_type_2 .   (rule 73)
    exp_type_2  ->  exp_type_2 . AND exp_type_3   (rule 74)

    AND 	shift, and go to state 75

    $default	reduce using rule 73 (exp_type_1)



state 43

    exp_type_2  ->  exp_type_3 .   (rule 75)
    exp_type_3  ->  exp_type_3 . relation_op arith_exp_type_1   (rule 76)

    GT  	shift, and go to state 76
    LT  	shift, and go to state 77
    GE  	shift, and go to state 78
    LE  	shift, and go to state 79
    EQ  	shift, and go to state 80
    NE  	shift, and go to state 81

    $default	reduce using rule 75 (exp_type_2)

    relation_op	go to state 82



state 44

    exp_type_3  ->  arith_exp_type_1 .   (rule 77)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 78)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 77 (exp_type_3)

    plus_minus_op	go to state 85



state 45

    arith_exp_type_1  ->  arith_exp_type_2 .   (rule 79)
    arith_exp_type_2  ->  arith_exp_type_2 . mul_div_op unary_exp   (rule 80)

    MUL 	shift, and go to state 86
    DIV 	shift, and go to state 87
    MOD 	shift, and go to state 88

    $default	reduce using rule 79 (arith_exp_type_1)

    mul_div_op	go to state 89



state 46

    arith_exp_type_2  ->  unary_exp .   (rule 81)

    $default	reduce using rule 81 (arith_exp_type_2)



state 47

    unary_exp  ->  term .   (rule 83)

    $default	reduce using rule 83 (unary_exp)



state 48

    term  ->  func_call .   (rule 85)

    $default	reduce using rule 85 (term)



state 49

    term  ->  consts .   (rule 86)

    $default	reduce using rule 86 (term)



state 50

    consts  ->  intg .   (rule 94)

    $default	reduce using rule 94 (consts)



state 51

    consts  ->  floats .   (rule 95)

    $default	reduce using rule 95 (consts)



state 52

    unary_exp  ->  unary_operator . term   (rule 82)

    SUB 	shift, and go to state 90
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    term	go to state 91
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51



state 53

    exp  ->  id EQUAL exp_type_1 .   (rule 70)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74

    $default	reduce using rule 70 (exp)



state 54

    br_list1  ->  br_list1 LBP . exp_type_1 RBP   (rule 23)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 92
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 55

    exp  ->  id br_list1 EQUAL . exp_type_1   (rule 71)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 93
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 56

    grammar_start  ->  libraries decls INT MAIN LB RB . lcf stmts rcf   (rule 1)

    LC  	shift, and go to state 94

    lcf 	go to state 95



state 57

    var_list  ->  var_list COMMA var .   (rule 15)

    $default	reduce using rule 15 (var_list)



state 58

    var  ->  id .   (rule 17)
    var  ->  id . br_list   (rule 18)

    LBP 	shift, and go to state 30

    $default	reduce using rule 17 (var)

    br_list	go to state 32



state 59

    var_decl  ->  type var EQUAL exp_type_1 . SEMI   (rule 11)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74
    SEMI	shift, and go to state 96



state 60

    intg  ->  SUB . INTEGERS   (rule 97)

    INTEGERS	shift, and go to state 68



state 61

    br_list  ->  LBP intg . RBP   (rule 20)

    RBP 	shift, and go to state 97



state 62

    br_list  ->  br_list LBP . intg RBP   (rule 21)

    SUB 	shift, and go to state 60
    INTEGERS	shift, and go to state 37

    intg	go to state 98



state 63

    func_decl  ->  type id lbf decl_plist . RB lcf body rcf func_end   (rule 24)

    RB  	shift, and go to state 99



state 64

    decl_plist  ->  @1 . decl_pl   (rule 31)

    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7

    type	go to state 101
    decl_pl	go to state 102
    decl_param	go to state 103



state 65

    func_decl  ->  void id lbf decl_plist . RB lcf body rcf func_end   (rule 25)

    RB  	shift, and go to state 104



state 66

    unary_operator  ->  ADD ADD .   (rule 112)

    $default	reduce using rule 112 (unary_operator)



state 67

    unary_operator  ->  SUB SUB .   (rule 111)

    $default	reduce using rule 111 (unary_operator)



state 68

    intg  ->  SUB INTEGERS .   (rule 97)

    $default	reduce using rule 97 (intg)



state 69

    floats  ->  SUB FLOATING_POINTS .   (rule 99)

    $default	reduce using rule 99 (floats)



state 70

    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)
    term  ->  LB exp_type_1 . RB   (rule 84)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 105



state 71

    func_call  ->  id LB . args RB   (rule 89)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    $default	reduce using rule 91 (args)

    id  	go to state 40
    arith_exp_type_1	go to state 106
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    args	go to state 107
    args_list	go to state 108
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 72

    br_list1  ->  br_list1 . LBP exp_type_1 RBP   (rule 23)
    term  ->  id br_list1 .   (rule 88)

    LBP 	shift, and go to state 54

    $default	reduce using rule 88 (term)



state 73

    br_list1  ->  LBP exp_type_1 RBP .   (rule 22)

    $default	reduce using rule 22 (br_list1)



state 74

    exp_type_1  ->  exp_type_1 OR . exp_type_2   (rule 72)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_2	go to state 109
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 75

    exp_type_2  ->  exp_type_2 AND . exp_type_3   (rule 74)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_3	go to state 110
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 76

    relation_op  ->  GT .   (rule 105)

    $default	reduce using rule 105 (relation_op)



state 77

    relation_op  ->  LT .   (rule 106)

    $default	reduce using rule 106 (relation_op)



state 78

    relation_op  ->  GE .   (rule 107)

    $default	reduce using rule 107 (relation_op)



state 79

    relation_op  ->  LE .   (rule 108)

    $default	reduce using rule 108 (relation_op)



state 80

    relation_op  ->  EQ .   (rule 109)

    $default	reduce using rule 109 (relation_op)



state 81

    relation_op  ->  NE .   (rule 110)

    $default	reduce using rule 110 (relation_op)



state 82

    exp_type_3  ->  exp_type_3 relation_op . arith_exp_type_1   (rule 76)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_1	go to state 111
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 83

    plus_minus_op  ->  ADD .   (rule 100)

    $default	reduce using rule 100 (plus_minus_op)



state 84

    plus_minus_op  ->  SUB .   (rule 101)

    $default	reduce using rule 101 (plus_minus_op)



state 85

    arith_exp_type_1  ->  arith_exp_type_1 plus_minus_op . arith_exp_type_2   (rule 78)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_2	go to state 112
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 86

    mul_div_op  ->  MUL .   (rule 102)

    $default	reduce using rule 102 (mul_div_op)



state 87

    mul_div_op  ->  DIV .   (rule 103)

    $default	reduce using rule 103 (mul_div_op)



state 88

    mul_div_op  ->  MOD .   (rule 104)

    $default	reduce using rule 104 (mul_div_op)



state 89

    arith_exp_type_2  ->  arith_exp_type_2 mul_div_op . unary_exp   (rule 80)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    unary_exp	go to state 113
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 90

    intg  ->  SUB . INTEGERS   (rule 97)
    floats  ->  SUB . FLOATING_POINTS   (rule 99)

    INTEGERS	shift, and go to state 68
    FLOATING_POINTS	shift, and go to state 69



state 91

    unary_exp  ->  unary_operator term .   (rule 82)

    $default	reduce using rule 82 (unary_exp)



state 92

    br_list1  ->  br_list1 LBP exp_type_1 . RBP   (rule 23)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    RBP 	shift, and go to state 114
    OR  	shift, and go to state 74



state 93

    exp  ->  id br_list1 EQUAL exp_type_1 .   (rule 71)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74

    $default	reduce using rule 71 (exp)



state 94

    lcf  ->  LC .   (rule 27)

    $default	reduce using rule 27 (lcf)



state 95

    grammar_start  ->  libraries decls INT MAIN LB RB lcf . stmts rcf   (rule 1)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124

    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 129
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 96

    var_decl  ->  type var EQUAL exp_type_1 SEMI .   (rule 11)

    $default	reduce using rule 11 (var_decl)



state 97

    br_list  ->  LBP intg RBP .   (rule 20)

    $default	reduce using rule 20 (br_list)



state 98

    br_list  ->  br_list LBP intg . RBP   (rule 21)

    RBP 	shift, and go to state 136



state 99

    func_decl  ->  type id lbf decl_plist RB . lcf body rcf func_end   (rule 24)

    LC  	shift, and go to state 94

    lcf 	go to state 137



state 100

    type  ->  INT .   (rule 12)

    $default	reduce using rule 12 (type)



state 101

    decl_param  ->  type . var   (rule 35)

    ID  	shift, and go to state 8

    var 	go to state 138
    id  	go to state 58



state 102

    decl_plist  ->  @1 decl_pl .   (rule 31)

    $default	reduce using rule 31 (decl_plist)



state 103

    decl_pl  ->  decl_param . COMMA decl_pl   (rule 33)
    decl_pl  ->  decl_param .   (rule 34)

    COMMA	shift, and go to state 139

    $default	reduce using rule 34 (decl_pl)



state 104

    func_decl  ->  void id lbf decl_plist RB . lcf body rcf func_end   (rule 25)

    LC  	shift, and go to state 94

    lcf 	go to state 140



state 105

    term  ->  LB exp_type_1 RB .   (rule 84)

    $default	reduce using rule 84 (term)



state 106

    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 78)
    args_list  ->  arith_exp_type_1 .   (rule 93)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 93 (args_list)

    plus_minus_op	go to state 85



state 107

    func_call  ->  id LB args . RB   (rule 89)

    RB  	shift, and go to state 141



state 108

    args  ->  args_list .   (rule 90)
    args_list  ->  args_list . COMMA arith_exp_type_1   (rule 92)

    COMMA	shift, and go to state 142

    $default	reduce using rule 90 (args)



state 109

    exp_type_1  ->  exp_type_1 OR exp_type_2 .   (rule 72)
    exp_type_2  ->  exp_type_2 . AND exp_type_3   (rule 74)

    AND 	shift, and go to state 75

    $default	reduce using rule 72 (exp_type_1)



state 110

    exp_type_2  ->  exp_type_2 AND exp_type_3 .   (rule 74)
    exp_type_3  ->  exp_type_3 . relation_op arith_exp_type_1   (rule 76)

    GT  	shift, and go to state 76
    LT  	shift, and go to state 77
    GE  	shift, and go to state 78
    LE  	shift, and go to state 79
    EQ  	shift, and go to state 80
    NE  	shift, and go to state 81

    $default	reduce using rule 74 (exp_type_2)

    relation_op	go to state 82



state 111

    exp_type_3  ->  exp_type_3 relation_op arith_exp_type_1 .   (rule 76)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 78)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 76 (exp_type_3)

    plus_minus_op	go to state 85



state 112

    arith_exp_type_1  ->  arith_exp_type_1 plus_minus_op arith_exp_type_2 .   (rule 78)
    arith_exp_type_2  ->  arith_exp_type_2 . mul_div_op unary_exp   (rule 80)

    MUL 	shift, and go to state 86
    DIV 	shift, and go to state 87
    MOD 	shift, and go to state 88

    $default	reduce using rule 78 (arith_exp_type_1)

    mul_div_op	go to state 89



state 113

    arith_exp_type_2  ->  arith_exp_type_2 mul_div_op unary_exp .   (rule 80)

    $default	reduce using rule 80 (arith_exp_type_2)



state 114

    br_list1  ->  br_list1 LBP exp_type_1 RBP .   (rule 23)

    $default	reduce using rule 23 (br_list1)



state 115

    stmt  ->  error . SEMI   (rule 54)

    SEMI	shift, and go to state 143



state 116

    stmt  ->  PRINT . LB args1 RB SEMI   (rule 52)

    LB  	shift, and go to state 144



state 117

    return_exp  ->  RETURN .   (rule 68)
    return_exp  ->  RETURN . exp_type_1   (rule 69)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    $default	reduce using rule 68 (return_exp)

    id  	go to state 40
    exp_type_1	go to state 145
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 118

    stmt  ->  IF . LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF . LB exp_type_1 RB lcf stmts rcf   (rule 46)

    LB  	shift, and go to state 146



state 119

    stmt  ->  FOR . LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    LB  	shift, and go to state 147



state 120

    stmt  ->  READ . LB args RB SEMI   (rule 53)

    LB  	shift, and go to state 148



state 121

    stmt  ->  WHILE . LB exp_type_1 RB lcf stmts rcf   (rule 44)

    LB  	shift, and go to state 149



state 122

    break  ->  BREAK .   (rule 62)

    $default	reduce using rule 62 (break)



state 123

    continue  ->  CONTINUE .   (rule 63)

    $default	reduce using rule 63 (continue)



state 124

    stmt  ->  SWITCH . LB exp_type_1 RB LC case_exp default_exp RC   (rule 47)

    LB  	shift, and go to state 150



state 125

    stmt  ->  var_decl .   (rule 40)

    $default	reduce using rule 40 (stmt)



state 126

    var_decl  ->  type . var_list SEMI   (rule 10)
    var_decl  ->  type . var EQUAL exp_type_1 SEMI   (rule 11)

    ID  	shift, and go to state 8

    var_list	go to state 18
    var 	go to state 19
    id  	go to state 58



state 127

    exp  ->  id . EQUAL exp_type_1   (rule 70)
    exp  ->  id . br_list1 EQUAL exp_type_1   (rule 71)
    term  ->  id .   (rule 87)
    term  ->  id . br_list1   (rule 88)
    func_call  ->  id . LB args RB   (rule 89)

    LBP 	shift, and go to state 22
    LB  	shift, and go to state 71
    EQUAL	shift, and go to state 23

    $default	reduce using rule 87 (term)

    br_list1	go to state 151



state 128

    stmt  ->  lcf . body rcf   (rule 51)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124


    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    body	go to state 152
    stmts	go to state 153
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 129

    grammar_start  ->  libraries decls INT MAIN LB RB lcf stmts . rcf   (rule 1)

    RC  	shift, and go to state 154

    rcf 	go to state 155



state 130

    stmts  ->  stmt . stmts   (rule 38)
    stmts  ->  stmt .   (rule 39)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124


    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 156
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 131

    stmt  ->  break . SEMI   (rule 49)

    SEMI	shift, and go to state 157



state 132

    stmt  ->  continue . SEMI   (rule 48)

    SEMI	shift, and go to state 158



state 133

    stmt  ->  return_exp . SEMI   (rule 50)

    SEMI	shift, and go to state 159



state 134

    stmt  ->  exp . SEMI   (rule 41)

    SEMI	shift, and go to state 160



state 135

    stmt  ->  exp_type_1 . SEMI   (rule 42)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74
    SEMI	shift, and go to state 161



state 136

    br_list  ->  br_list LBP intg RBP .   (rule 21)

    $default	reduce using rule 21 (br_list)



state 137

    func_decl  ->  type id lbf decl_plist RB lcf . body rcf func_end   (rule 24)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124


    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    body	go to state 162
    stmts	go to state 153
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 138

    decl_param  ->  type var .   (rule 35)

    $default	reduce using rule 35 (decl_param)



state 139

    decl_pl  ->  decl_param COMMA . decl_pl   (rule 33)

    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7

    type	go to state 101
    decl_pl	go to state 163
    decl_param	go to state 103



state 140

    func_decl  ->  void id lbf decl_plist RB lcf . body rcf func_end   (rule 25)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124


    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    body	go to state 164
    stmts	go to state 153
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 141

    func_call  ->  id LB args RB .   (rule 89)

    $default	reduce using rule 89 (func_call)



state 142

    args_list  ->  args_list COMMA . arith_exp_type_1   (rule 92)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_1	go to state 165
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 143

    stmt  ->  error SEMI .   (rule 54)

    $default	reduce using rule 54 (stmt)



state 144

    stmt  ->  PRINT LB . args1 RB SEMI   (rule 52)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39
    STRING	shift, and go to state 166

    $default	reduce using rule 56 (args1)

    id  	go to state 40
    args1	go to state 167
    args_list1	go to state 168
    string	go to state 169
    arith_exp_type_1	go to state 170
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 145

    return_exp  ->  RETURN exp_type_1 .   (rule 69)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74

    $default	reduce using rule 69 (return_exp)



state 146

    stmt  ->  IF LB . exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB . exp_type_1 RB lcf stmts rcf   (rule 46)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 171
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 147

    stmt  ->  FOR LB . exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    ID  	shift, and go to state 8

    id  	go to state 14
    exp 	go to state 172



state 148

    stmt  ->  READ LB . args RB SEMI   (rule 53)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    $default	reduce using rule 91 (args)

    id  	go to state 40
    arith_exp_type_1	go to state 106
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    args	go to state 173
    args_list	go to state 108
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 149

    stmt  ->  WHILE LB . exp_type_1 RB lcf stmts rcf   (rule 44)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 174
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 150

    stmt  ->  SWITCH LB . exp_type_1 RB LC case_exp default_exp RC   (rule 47)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 175
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 151

    br_list1  ->  br_list1 . LBP exp_type_1 RBP   (rule 23)
    exp  ->  id br_list1 . EQUAL exp_type_1   (rule 71)
    term  ->  id br_list1 .   (rule 88)

    LBP 	shift, and go to state 54
    EQUAL	shift, and go to state 55

    $default	reduce using rule 88 (term)



state 152

    stmt  ->  lcf body . rcf   (rule 51)

    RC  	shift, and go to state 154

    rcf 	go to state 176



state 153

    body  ->  stmts .   (rule 36)

    $default	reduce using rule 36 (body)



state 154

    rcf  ->  RC .   (rule 28)

    $default	reduce using rule 28 (rcf)



state 155

    grammar_start  ->  libraries decls INT MAIN LB RB lcf stmts rcf .   (rule 1)

    $default	reduce using rule 1 (grammar_start)



state 156

    stmts  ->  stmt stmts .   (rule 38)

    $default	reduce using rule 38 (stmts)



state 157

    stmt  ->  break SEMI .   (rule 49)

    $default	reduce using rule 49 (stmt)



state 158

    stmt  ->  continue SEMI .   (rule 48)

    $default	reduce using rule 48 (stmt)



state 159

    stmt  ->  return_exp SEMI .   (rule 50)

    $default	reduce using rule 50 (stmt)



state 160

    stmt  ->  exp SEMI .   (rule 41)

    $default	reduce using rule 41 (stmt)



state 161

    stmt  ->  exp_type_1 SEMI .   (rule 42)

    $default	reduce using rule 42 (stmt)



state 162

    func_decl  ->  type id lbf decl_plist RB lcf body . rcf func_end   (rule 24)

    RC  	shift, and go to state 154

    rcf 	go to state 177



state 163

    decl_pl  ->  decl_param COMMA decl_pl .   (rule 33)

    $default	reduce using rule 33 (decl_pl)



state 164

    func_decl  ->  void id lbf decl_plist RB lcf body . rcf func_end   (rule 25)

    RC  	shift, and go to state 154

    rcf 	go to state 178



state 165

    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 78)
    args_list  ->  args_list COMMA arith_exp_type_1 .   (rule 92)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 92 (args_list)

    plus_minus_op	go to state 85



state 166

    string  ->  STRING .   (rule 61)

    $default	reduce using rule 61 (string)



state 167

    stmt  ->  PRINT LB args1 . RB SEMI   (rule 52)

    RB  	shift, and go to state 179



state 168

    args1  ->  args_list1 .   (rule 55)
    args_list1  ->  args_list1 . COMMA arith_exp_type_1   (rule 57)
    args_list1  ->  args_list1 . COMMA string   (rule 59)

    COMMA	shift, and go to state 180

    $default	reduce using rule 55 (args1)



state 169

    args_list1  ->  string .   (rule 60)

    $default	reduce using rule 60 (args_list1)



state 170

    args_list1  ->  arith_exp_type_1 .   (rule 58)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 78)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 58 (args_list1)

    plus_minus_op	go to state 85



state 171

    stmt  ->  IF LB exp_type_1 . RB lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 . RB lcf stmts rcf   (rule 46)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 181



state 172

    stmt  ->  FOR LB exp . SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    SEMI	shift, and go to state 182



state 173

    stmt  ->  READ LB args . RB SEMI   (rule 53)

    RB  	shift, and go to state 183



state 174

    stmt  ->  WHILE LB exp_type_1 . RB lcf stmts rcf   (rule 44)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 184



state 175

    stmt  ->  SWITCH LB exp_type_1 . RB LC case_exp default_exp RC   (rule 47)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 185



state 176

    stmt  ->  lcf body rcf .   (rule 51)

    $default	reduce using rule 51 (stmt)



state 177

    func_decl  ->  type id lbf decl_plist RB lcf body rcf . func_end   (rule 24)

    $default	reduce using rule 29 (func_end)

    func_end	go to state 186



state 178

    func_decl  ->  void id lbf decl_plist RB lcf body rcf . func_end   (rule 25)

    $default	reduce using rule 29 (func_end)

    func_end	go to state 187



state 179

    stmt  ->  PRINT LB args1 RB . SEMI   (rule 52)

    SEMI	shift, and go to state 188



state 180

    args_list1  ->  args_list1 COMMA . arith_exp_type_1   (rule 57)
    args_list1  ->  args_list1 COMMA . string   (rule 59)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39
    STRING	shift, and go to state 166

    id  	go to state 40
    string	go to state 189
    arith_exp_type_1	go to state 190
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 181

    stmt  ->  IF LB exp_type_1 RB . lcf stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB . lcf stmts rcf   (rule 46)

    LC  	shift, and go to state 94

    lcf 	go to state 191



state 182

    stmt  ->  FOR LB exp SEMI . exp_type_1 SEMI exp_type_1 RB lcf stmts rcf   (rule 43)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 192
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 183

    stmt  ->  READ LB args RB . SEMI   (rule 53)

    SEMI	shift, and go to state 193



state 184

    stmt  ->  WHILE LB exp_type_1 RB . lcf stmts rcf   (rule 44)

    LC  	shift, and go to state 94

    lcf 	go to state 194



state 185

    stmt  ->  SWITCH LB exp_type_1 RB . LC case_exp default_exp RC   (rule 47)

    LC  	shift, and go to state 195



state 186

    func_decl  ->  type id lbf decl_plist RB lcf body rcf func_end .   (rule 24)

    $default	reduce using rule 24 (func_decl)



state 187

    func_decl  ->  void id lbf decl_plist RB lcf body rcf func_end .   (rule 25)

    $default	reduce using rule 25 (func_decl)



state 188

    stmt  ->  PRINT LB args1 RB SEMI .   (rule 52)

    $default	reduce using rule 52 (stmt)



state 189

    args_list1  ->  args_list1 COMMA string .   (rule 59)

    $default	reduce using rule 59 (args_list1)



state 190

    args_list1  ->  args_list1 COMMA arith_exp_type_1 .   (rule 57)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 78)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84

    $default	reduce using rule 57 (args_list1)

    plus_minus_op	go to state 85



state 191

    stmt  ->  IF LB exp_type_1 RB lcf . stmts rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB lcf . stmts rcf   (rule 46)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124

    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 196
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 192

    stmt  ->  FOR LB exp SEMI exp_type_1 . SEMI exp_type_1 RB lcf stmts rcf   (rule 43)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74
    SEMI	shift, and go to state 197



state 193

    stmt  ->  READ LB args RB SEMI .   (rule 53)

    $default	reduce using rule 53 (stmt)



state 194

    stmt  ->  WHILE LB exp_type_1 RB lcf . stmts rcf   (rule 44)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124

    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 198
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 195

    stmt  ->  SWITCH LB exp_type_1 RB LC . case_exp default_exp RC   (rule 47)

    CASE	shift, and go to state 199

    $default	reduce using rule 65 (case_exp)

    case_exp	go to state 200



state 196

    stmt  ->  IF LB exp_type_1 RB lcf stmts . rcf ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB lcf stmts . rcf   (rule 46)

    RC  	shift, and go to state 154

    rcf 	go to state 201



state 197

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI . exp_type_1 RB lcf stmts rcf   (rule 43)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    exp_type_1	go to state 202
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 198

    stmt  ->  WHILE LB exp_type_1 RB lcf stmts . rcf   (rule 44)

    RC  	shift, and go to state 154

    rcf 	go to state 203



state 199

    case_exp  ->  CASE . LB arith_exp_type_1 RB COLON lcf stmts rcf case_exp   (rule 64)

    LB  	shift, and go to state 204



state 200

    stmt  ->  SWITCH LB exp_type_1 RB LC case_exp . default_exp RC   (rule 47)

    DEFAULT	shift, and go to state 205

    $default	reduce using rule 67 (default_exp)

    default_exp	go to state 206



state 201

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf . ELSE lcf stmts rcf   (rule 45)
    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf .   (rule 46)

    ELSE	shift, and go to state 207

    $default	reduce using rule 46 (stmt)



state 202

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 . RB lcf stmts rcf   (rule 43)
    exp_type_1  ->  exp_type_1 . OR exp_type_2   (rule 72)

    OR  	shift, and go to state 74
    RB  	shift, and go to state 208



state 203

    stmt  ->  WHILE LB exp_type_1 RB lcf stmts rcf .   (rule 44)

    $default	reduce using rule 44 (stmt)



state 204

    case_exp  ->  CASE LB . arith_exp_type_1 RB COLON lcf stmts rcf case_exp   (rule 64)

    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LB  	shift, and go to state 39

    id  	go to state 40
    arith_exp_type_1	go to state 209
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 205

    default_exp  ->  DEFAULT . COLON lcf stmts rcf   (rule 66)

    COLON	shift, and go to state 210



state 206

    stmt  ->  SWITCH LB exp_type_1 RB LC case_exp default_exp . RC   (rule 47)

    RC  	shift, and go to state 211



state 207

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE . lcf stmts rcf   (rule 45)

    LC  	shift, and go to state 94

    lcf 	go to state 212



state 208

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB . lcf stmts rcf   (rule 43)

    LC  	shift, and go to state 94

    lcf 	go to state 213



state 209

    case_exp  ->  CASE LB arith_exp_type_1 . RB COLON lcf stmts rcf case_exp   (rule 64)
    arith_exp_type_1  ->  arith_exp_type_1 . plus_minus_op arith_exp_type_2   (rule 78)

    ADD 	shift, and go to state 83
    SUB 	shift, and go to state 84
    RB  	shift, and go to state 214

    plus_minus_op	go to state 85



state 210

    default_exp  ->  DEFAULT COLON . lcf stmts rcf   (rule 66)

    LC  	shift, and go to state 94

    lcf 	go to state 215



state 211

    stmt  ->  SWITCH LB exp_type_1 RB LC case_exp default_exp RC .   (rule 47)

    $default	reduce using rule 47 (stmt)



state 212

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE lcf . stmts rcf   (rule 45)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124

    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 216
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 213

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf . stmts rcf   (rule 43)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124

    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 217
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 214

    case_exp  ->  CASE LB arith_exp_type_1 RB . COLON lcf stmts rcf case_exp   (rule 64)

    COLON	shift, and go to state 218



state 215

    default_exp  ->  DEFAULT COLON lcf . stmts rcf   (rule 66)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124

    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 219
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 216

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts . rcf   (rule 45)

    RC  	shift, and go to state 154

    rcf 	go to state 220



state 217

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts . rcf   (rule 43)

    RC  	shift, and go to state 154

    rcf 	go to state 221



state 218

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON . lcf stmts rcf case_exp   (rule 64)

    LC  	shift, and go to state 94

    lcf 	go to state 222



state 219

    default_exp  ->  DEFAULT COLON lcf stmts . rcf   (rule 66)

    RC  	shift, and go to state 154

    rcf 	go to state 223



state 220

    stmt  ->  IF LB exp_type_1 RB lcf stmts rcf ELSE lcf stmts rcf .   (rule 45)

    $default	reduce using rule 45 (stmt)



state 221

    stmt  ->  FOR LB exp SEMI exp_type_1 SEMI exp_type_1 RB lcf stmts rcf .   (rule 43)

    $default	reduce using rule 43 (stmt)



state 222

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf . stmts rcf case_exp   (rule 64)

    error	shift, and go to state 115
    ADD 	shift, and go to state 35
    SUB 	shift, and go to state 36
    INT 	shift, and go to state 100
    FLOAT	shift, and go to state 7
    PRINT	shift, and go to state 116
    RETURN	shift, and go to state 117
    IF  	shift, and go to state 118
    FOR 	shift, and go to state 119
    READ	shift, and go to state 120
    WHILE	shift, and go to state 121
    BREAK	shift, and go to state 122
    CONTINUE	shift, and go to state 123
    INTEGERS	shift, and go to state 37
    FLOATING_POINTS	shift, and go to state 38
    ID  	shift, and go to state 8
    LC  	shift, and go to state 94
    LB  	shift, and go to state 39
    SWITCH	shift, and go to state 124

    var_decl	go to state 125
    type	go to state 126
    id  	go to state 127
    lcf 	go to state 128
    stmts	go to state 224
    stmt	go to state 130
    break	go to state 131
    continue	go to state 132
    return_exp	go to state 133
    exp 	go to state 134
    exp_type_1	go to state 135
    exp_type_2	go to state 42
    exp_type_3	go to state 43
    arith_exp_type_1	go to state 44
    arith_exp_type_2	go to state 45
    unary_exp	go to state 46
    term	go to state 47
    func_call	go to state 48
    consts	go to state 49
    intg	go to state 50
    floats	go to state 51
    unary_operator	go to state 52



state 223

    default_exp  ->  DEFAULT COLON lcf stmts rcf .   (rule 66)

    $default	reduce using rule 66 (default_exp)



state 224

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf stmts . rcf case_exp   (rule 64)

    RC  	shift, and go to state 154

    rcf 	go to state 225



state 225

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf stmts rcf . case_exp   (rule 64)

    CASE	shift, and go to state 199

    $default	reduce using rule 65 (case_exp)

    case_exp	go to state 226



state 226

    case_exp  ->  CASE LB arith_exp_type_1 RB COLON lcf stmts rcf case_exp .   (rule 64)

    $default	reduce using rule 64 (case_exp)



state 227

    $   	go to state 228



state 228

    $   	go to state 229



state 229

    $default	accept
